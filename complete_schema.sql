-- ==========================================
-- COMPLETE ABECSA DATABASE SETUP
-- ==========================================

-- 1. TABLES SETUP
-- Safely create tables if they don't exist

-- Profiles
CREATE TABLE IF NOT EXISTS profiles (
  id uuid REFERENCES auth.users NOT NULL PRIMARY KEY,
  full_name text,
  role text CHECK (role IN ('admin', 'marketing_manager', 'customer')),
  email text,
  visible_password text
);
ALTER TABLE profiles ENABLE ROW LEVEL SECURITY;

-- Messages
CREATE TABLE IF NOT EXISTS messages (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sender_id uuid REFERENCES auth.users NOT NULL,
  conversation_id uuid,
  content text,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now())
);
ALTER TABLE messages ENABLE ROW LEVEL SECURITY;

-- Websites
CREATE TABLE IF NOT EXISTS websites (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users NOT NULL,
  manager_id uuid REFERENCES auth.users(id),
  name text NOT NULL,
  url text,
  status text DEFAULT 'Pending',
  plan text,
  expiry_date date
);
ALTER TABLE websites ENABLE ROW LEVEL SECURITY;

-- User Assets (Licenses/Certificates/Images)
CREATE TABLE IF NOT EXISTS user_assets (
  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id uuid REFERENCES auth.users(id) NOT NULL,
  name text NOT NULL,
  type text NOT NULL, -- Constraint managed below
  value text NOT NULL,
  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);
ALTER TABLE user_assets ENABLE ROW LEVEL SECURITY;


-- 2. COLUMN UPDATES (Idempotent)
-- Ensure all necessary columns exist
DO $$ 
BEGIN
  -- Profiles: visible_password
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='visible_password') THEN
    ALTER TABLE profiles ADD COLUMN visible_password text;
  END IF;

  -- Profiles: manager_id
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='profiles' AND column_name='manager_id') THEN
    ALTER TABLE profiles ADD COLUMN manager_id uuid REFERENCES auth.users(id);
  END IF;

  -- Messages: conversation_id
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='messages' AND column_name='conversation_id') THEN
    ALTER TABLE messages ADD COLUMN conversation_id uuid;
  END IF;

  -- Websites: manager_id
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='websites' AND column_name='manager_id') THEN
    ALTER TABLE websites ADD COLUMN manager_id uuid REFERENCES auth.users(id);
  END IF;

  -- Websites: user_id
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name='websites' AND column_name='user_id') THEN
    ALTER TABLE websites ADD COLUMN user_id uuid REFERENCES auth.users(id);
  END IF;
END $$;


-- 3. CONSTRAINTS UPDATE
-- Ensure user_assets type allows 'Image'
DO $$ 
BEGIN
  ALTER TABLE user_assets DROP CONSTRAINT IF EXISTS user_assets_type_check;
  ALTER TABLE user_assets ADD CONSTRAINT user_assets_type_check CHECK (type IN ('License', 'Certificate', 'Image'));
EXCEPTION
  WHEN OTHERS THEN
    RAISE NOTICE 'Constraint update warning: %', SQLERRM;
END $$;


-- 4. ADMIN HELPER FUNCTION
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS boolean AS $$
BEGIN
  RETURN EXISTS (
    SELECT 1 FROM profiles
    WHERE id = auth.uid() AND role = 'admin'
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;


-- 5. RLS POLICIES (Reset and Recreate)

-- === PROFILES ===
DROP POLICY IF EXISTS "Public profiles are viewable by everyone" ON profiles;
DROP POLICY IF EXISTS "Users can insert their own profile" ON profiles;
DROP POLICY IF EXISTS "Users can update their own profile" ON profiles;
DROP POLICY IF EXISTS "Admins can insert profiles" ON profiles;
DROP POLICY IF EXISTS "Admins can update profiles" ON profiles;
DROP POLICY IF EXISTS "Admins can delete profiles" ON profiles;

CREATE POLICY "Public profiles are viewable by everyone" ON profiles FOR SELECT USING (true);
CREATE POLICY "Users can insert their own profile" ON profiles FOR INSERT WITH CHECK (auth.uid() = id);
CREATE POLICY "Users can update their own profile" ON profiles FOR UPDATE USING (auth.uid() = id);
CREATE POLICY "Admins can insert profiles" ON profiles FOR INSERT WITH CHECK (is_admin());
CREATE POLICY "Admins can update profiles" ON profiles FOR UPDATE USING (is_admin());
CREATE POLICY "Admins can delete profiles" ON profiles FOR DELETE USING (is_admin());

-- === MESSAGES ===
DROP POLICY IF EXISTS "Messages are viewable by everyone" ON messages;
DROP POLICY IF EXISTS "Users can insert messages" ON messages;
DROP POLICY IF EXISTS "Admins can insert messages" ON messages;
DROP POLICY IF EXISTS "Admins can update messages" ON messages;
DROP POLICY IF EXISTS "Admins can delete messages" ON messages;

CREATE POLICY "Messages are viewable by everyone" ON messages FOR SELECT USING (true);
CREATE POLICY "Users can insert messages" ON messages FOR INSERT WITH CHECK (auth.uid() = sender_id);
-- Admin overrides
CREATE POLICY "Admins can insert messages" ON messages FOR INSERT WITH CHECK (is_admin());
CREATE POLICY "Admins can update messages" ON messages FOR UPDATE USING (is_admin());
CREATE POLICY "Admins can delete messages" ON messages FOR DELETE USING (is_admin());

-- === WEBSITES ===
DROP POLICY IF EXISTS "Users can view own websites" ON websites;
DROP POLICY IF EXISTS "Users can insert own websites" ON websites;
DROP POLICY IF EXISTS "Managers can view sold websites" ON websites;
DROP POLICY IF EXISTS "Managers can insert websites" ON websites;
DROP POLICY IF EXISTS "Admins View All" ON websites;
DROP POLICY IF EXISTS "Admins can insert websites" ON websites;
DROP POLICY IF EXISTS "Admins can update websites" ON websites;
DROP POLICY IF EXISTS "Admins can delete websites" ON websites;

CREATE POLICY "Users can view own websites" ON websites FOR SELECT USING (auth.uid() = user_id);
CREATE POLICY "Users can insert own websites" ON websites FOR INSERT WITH CHECK (auth.uid() = user_id);
CREATE POLICY "Managers can view sold websites" ON websites FOR SELECT USING (auth.uid() = manager_id);
CREATE POLICY "Managers can insert websites" ON websites FOR INSERT WITH CHECK (auth.uid() = manager_id);
-- Admin overrides
CREATE POLICY "Admins View All" ON websites FOR SELECT USING (true);
CREATE POLICY "Admins can insert websites" ON websites FOR INSERT WITH CHECK (is_admin());
CREATE POLICY "Admins can update websites" ON websites FOR UPDATE USING (is_admin());
CREATE POLICY "Admins can delete websites" ON websites FOR DELETE USING (is_admin());

-- === USER ASSETS ===
DROP POLICY IF EXISTS "Users can view own assets" ON user_assets;
DROP POLICY IF EXISTS "Admins can manage assets" ON user_assets;

CREATE POLICY "Users can view own assets" ON user_assets FOR SELECT USING (auth.uid() = user_id);
-- Important: Allow Admins to Assign Assets (Insert/Update/Delete)
CREATE POLICY "Admins can manage assets" ON user_assets FOR ALL USING (is_admin());

-- 6. STORAGE BUCKETS (If using standard Supabase Storage SQL access)
-- Note: Requires pg_net extension or direct SQL access usually, but defining logical buckets here for record.
-- Creation logic usually 'INSERT INTO storage.buckets ...'
INSERT INTO storage.buckets (id, name, public) VALUES ('public-files', 'public-files', true) ON CONFLICT (id) DO NOTHING;

-- Storage Policies
DROP POLICY IF EXISTS "Public Read Access" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated Upload Access" ON storage.objects;

CREATE POLICY "Public Read Access" ON storage.objects FOR SELECT USING ( bucket_id = 'public-files' );
CREATE POLICY "Authenticated Upload Access" ON storage.objects FOR INSERT WITH CHECK ( bucket_id = 'public-files' AND auth.role() = 'authenticated' );
